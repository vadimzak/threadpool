{"version":3,"sources":["../src/ThreadPool.js"],"names":["DEFAULT_SLEEP_TIME_MS","TaskDesc","queueTime","Date","now","ThreadPool","maxThreadsCount","freeParam1","freeParam2","runAllQueued","queuedTasks","queuedCount","startedCount","endedCount","uncaughtErrors","closed","_taskData","Map","errorHandler","err","console","error","sleepTimeMs","maxQueueSize","Infinity","Array","isArray","preQueuedTasks","undefined","Error","preQueuedTask","_internalQueue","func","length","startTimeMs","_thereIsSomethingToWaitFor","_thereAreQueuedTasksThatCanRun","_thereIsSpaceForNewTasks","_popAndRunNextTask","endTimeMs","_throwUncaughtErrors","close","run","waitComplete","runTimes","from","values","filter","td","startTime","endTime","map","longestRunning","Math","max","_thereWereUncaughtErrors","push","index","set","taskToRun","shift","taskData","get","err2","emit","_thereAreRunningTasks","_newTasksCanBeQueued"],"mappings":"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","file":"ThreadPool.js","sourcesContent":["// @flow\r\n\r\nimport \"babel-polyfill\"\r\nimport EventEmitter from 'events'\r\n\r\nimport { sleep } from './asyncUtils'\r\n\r\nconst DEFAULT_SLEEP_TIME_MS = 100\r\n\r\nclass TaskDesc {\r\n  queueTime: number\r\n  startTime: ?number\r\n  endTime: ?number\r\n  err: ?Error\r\n\r\n  constructor() {\r\n    this.queueTime = Date.now()\r\n  }\r\n}\r\n\r\ntype ThreadPoolOptions = { errorHandler: ?Function, sleepTimeMs: ?number, maxQueueSize: ?number }\r\n\r\n/**\r\n * A thread-pool abstraction for ES6 async operations\",\r\n * \r\n * @export\r\n * @class ThreadPool\r\n * @extends {EventEmitter}\r\n */\r\nexport default class ThreadPool extends EventEmitter {\r\n  preQueuedTasks: Array<Function | Promise<*>>\r\n\r\n  startTimeMs: number\r\n  endTimeMs: number\r\n  maxThreadsCount: number\r\n  queuedTasks: Array<{ func: Function | Promise<*>, index: number }> = []\r\n  queuedCount: number = 0\r\n  startedCount: number = 0\r\n  endedCount: number = 0\r\n  errorHandler: Function\r\n  uncaughtErrors: Array<Error> = []\r\n  sleepTimeMs: number\r\n  closed: boolean = false\r\n  maxQueueSize: number\r\n  _taskData: Map<number, TaskDesc> = new Map()\r\n\r\n\r\n  static async run(maxThreadsCount: number, freeParam1: ThreadPoolOptions | Array<Function | Promise<*>> | void, freeParam2: Array<Function | Promise<*>> | void) {\r\n    return new ThreadPool(maxThreadsCount, freeParam1, freeParam2).runAllQueued()\r\n  }\r\n\r\n  /**\r\n   * Creates an instance of ThreadPool\r\n   */\r\n  constructor(maxThreadsCount: number, freeParam1: ThreadPoolOptions | Array<Function | Promise<*>> | void, freeParam2: Array<Function | Promise<*>> | void) {\r\n    super()\r\n\r\n    this.maxThreadsCount = maxThreadsCount \r\n\r\n    // set defualts\r\n    this.errorHandler = (err: Error) => console.error(err)  // eslint-disable-line no-console\r\n    this.sleepTimeMs = DEFAULT_SLEEP_TIME_MS\r\n    this.maxQueueSize = Infinity\r\n\r\n    if (Array.isArray(freeParam1)) {\r\n      this.preQueuedTasks = freeParam1\r\n    } else if (typeof freeParam1 === 'object') {\r\n      if (freeParam1.errorHandler != undefined)\r\n        this.errorHandler = freeParam1.errorHandler\r\n      if (freeParam1.sleepTimeMs != undefined)\r\n        this.sleepTimeMs = freeParam1.sleepTimeMs\r\n      if (freeParam1.maxQueueSize != undefined)\r\n        this.maxQueueSize = freeParam1.maxQueueSize\r\n    } \r\n\r\n    if (Array.isArray(freeParam2)) {\r\n      if (this.preQueuedTasks)\r\n        throw new Error('Tasks were set twice')\r\n      this.preQueuedTasks = freeParam2\r\n    } \r\n\r\n    if (maxThreadsCount <= 0) {\r\n      throw new Error(`ThreadPool maxThreadsCount must be greater than 0`)\r\n    }\r\n\r\n    if (this.preQueuedTasks) {\r\n      for (let preQueuedTask of this.preQueuedTasks) {\r\n        this._internalQueue(preQueuedTask)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queues a task (function / async function / Promise)\r\n   * \r\n   * @param  {Function|Promise<*>} func\r\n   */\r\n  async queue(func: Function | Promise<*>) {\r\n    if (this.closed)\r\n      throw new Error(`Trying to queue a job to a closed ThreadPool`)\r\n\r\n    // block till queue has space\r\n    if (this.maxQueueSize !== Infinity) {\r\n      while (this.queuedTasks.length >= this.maxQueueSize) {\r\n        await sleep(this.sleepTimeMs)\r\n      }\r\n    }\r\n\r\n    this._internalQueue(func)\r\n  }\r\n  \r\n  /**\r\n   * Starts executing all queued tasks\r\n   * \r\n   * This function can be awaited - it will return after the ThreadPool has been closed and all it's tasks completed, or after a task threw an error.\r\n   */\r\n  async run() {\r\n    // make sure tasks start executing async\r\n    await sleep(0)\r\n\r\n    this.startTimeMs = Date.now()\r\n    while (this._thereIsSomethingToWaitFor) {\r\n\r\n      // start new queued tasks\r\n      while (this._thereAreQueuedTasksThatCanRun && this._thereIsSpaceForNewTasks) {\r\n        this._popAndRunNextTask()\r\n      }\r\n\r\n      await sleep(this.sleepTimeMs)\r\n    }\r\n    this.endTimeMs = Date.now()\r\n\r\n    this._throwUncaughtErrors()\r\n  }\r\n\r\n  /**\r\n   * Closes the ThreadPool for further task queueing, the ThreadPool's completion can be awaited afte'r it's called\r\n   */\r\n  close() {\r\n    this.closed = true\r\n  }\r\n\r\n  /**\r\n   * Closes the ThreadPool, runs it's tasks and awaits their completion\r\n   */\r\n  async runAllQueued() {\r\n    this.close()\r\n    await this.run()\r\n  }\r\n\r\n  /**\r\n   * Awaits the closing and completion of all ThreadPool tasks\r\n   */\r\n  async waitComplete() {\r\n    while (this._thereIsSomethingToWaitFor) {\r\n      await sleep(this.sleepTimeMs)\r\n    }\r\n\r\n    this._throwUncaughtErrors()\r\n  }\r\n\r\n  /**\r\n   * Closes the ThreadPool and awaits the running and completion of all ThreadPool tasks\r\n   */\r\n  async closeAndWaitComplete() {\r\n    this.close()\r\n    await this.waitComplete()\r\n  }\r\n\r\n  /**\r\n   * Returns the time in milliseconds that passed since the last still uncompleted task started executing\r\n   */\r\n  getLongestStillRunningMs() {\r\n    let now = Date.now()\r\n    let runTimes = Array.from(this._taskData.values())\r\n      .filter(td => td.startTime && !td.endTime)\r\n      // $FlowIgnore\r\n      .map(td => now - td.startTime)\r\n    let longestRunning = Math.max(...runTimes)\r\n    return longestRunning\r\n  }\r\n\r\n  /****************** privates ******************/\r\n\r\n  get _thereIsSpaceForNewTasks(): boolean { return this.startedCount - this.endedCount < this.maxThreadsCount }\r\n  get _thereWereUncaughtErrors(): boolean { return this.uncaughtErrors.length > 0 }\r\n  get _newTasksCanBeQueued(): boolean { return !this.closed && !this._thereWereUncaughtErrors }\r\n  get _thereAreRunningTasks(): boolean { return this.startedCount - this.endedCount > 0 }\r\n  get _thereAreQueuedTasksThatCanRun(): boolean { return this.queuedTasks.length > 0 && !this._thereWereUncaughtErrors }\r\n  get _thereIsSomethingToWaitFor(): boolean { return this._thereAreRunningTasks || this._thereAreQueuedTasksThatCanRun || this._newTasksCanBeQueued }\r\n\r\n  _throwUncaughtErrors() {\r\n    if (this._thereWereUncaughtErrors) {\r\n      let error = (new Error(`${this.uncaughtErrors.length} errors were thrown during ThreadPool execution`): Object)\r\n      error.uncaughtErrors = this.uncaughtErrors\r\n      throw error\r\n    }\r\n  }\r\n\r\n  _internalQueue(func: Function | Promise<*>) {\r\n    this.queuedTasks.push({ func, index: this.queuedCount })\r\n    this._taskData.set(this.queuedCount, new TaskDesc())\r\n    this.queuedCount++\r\n  }\r\n\r\n  async _popAndRunNextTask () {\r\n    let taskToRun = this.queuedTasks.shift()\r\n    let taskData = this._taskData.get(taskToRun.index)\r\n    if (!taskData)\r\n      throw new Error('unexpected')\r\n    try {\r\n      this.startedCount++\r\n      taskData.startTime = Date.now()\r\n      if (typeof taskToRun.func === 'function')\r\n        await taskToRun.func()\r\n      else\r\n        await taskToRun.func\r\n    } catch(err) {\r\n      try {\r\n        taskData.err = err\r\n        this.errorHandler(err)\r\n      } catch(err2) {\r\n        this.uncaughtErrors.push(err2)\r\n      }\r\n    }\r\n    this.endedCount++\r\n    taskData.endTime = Date.now()\r\n\r\n    // fire 'progress' event\r\n    this.emit('progress', { endedCount: this.endedCount })\r\n  }\r\n}\r\n"]}