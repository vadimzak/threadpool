{"version":3,"sources":["../src/ThreadPool.js"],"names":["DEFAULT_SLEEP_TIME_MS","TaskDesc","constructor","queueTime","Date","now","ThreadPool","maxThreadsCount","cpus","length","errorHandler","sleepTimeMs","maxQueueSize","Infinity","queuedTasks","queuedCount","startedCount","endedCount","uncaughtErrors","closed","_taskData","Map","Error","err","console","error","queue","func","push","index","set","_popAndRunNextTask","taskToRun","shift","taskData","get","startTime","err2","endTime","emit","runAllQueued","close","run","startTimeMs","endTimeMs","waitComplete","closeAndWaitComplete","getLongestStillRunningMs","runTimes","Array","from","values","filter","td","map","longestRunning","Math","max"],"mappings":"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","file":"ThreadPool.js","sourcesContent":["// @flow\r\n\r\nimport EventEmitter from 'events'\r\nimport os from 'os'\r\n\r\nimport { sleep } from './asyncUtils'\r\n\r\nconst DEFAULT_SLEEP_TIME_MS = 100\r\n\r\nclass TaskDesc {\r\n  queueTime: number\r\n  startTime: ?number\r\n  endTime: ?number\r\n  err: ?Error\r\n\r\n  constructor() {\r\n    this.queueTime = Date.now()\r\n  }\r\n}\r\n\r\n/**\r\n * A thread-pool abstraction for ES6 async operations\",\r\n * \r\n * @export\r\n * @class ThreadPool\r\n * @extends {EventEmitter}\r\n */\r\nexport default class ThreadPool extends EventEmitter {\r\n  startTimeMs: number\r\n  endTimeMs: number\r\n  maxThreadsCount: number\r\n  queuedTasks: Array<{ func: Function, index: number }> = []\r\n  queuedCount: number = 0\r\n  startedCount: number = 0\r\n  endedCount: number = 0\r\n  errorHandler: Function\r\n  uncaughtErrors: Array<Error> = []\r\n  sleepTimeMs: number\r\n  closed: boolean = false\r\n  maxQueueSize: number\r\n  _taskData: Map<number, TaskDesc> = new Map()\r\n\r\n  constructor(maxThreadsCount: number = os.cpus().length, errorHandler: ?Function, sleepTimeMs: number = DEFAULT_SLEEP_TIME_MS, maxQueueSize: number = Infinity) {\r\n    super()\r\n    \r\n    if (maxThreadsCount <= 0) {\r\n      throw new Error(`ThreadPool maxThreadsCount must be greater than 0`)\r\n    }\r\n    this.maxThreadsCount = maxThreadsCount\r\n    this.errorHandler = errorHandler || ((err) => console.error(err))  // eslint-disable-line no-console\r\n    this.sleepTimeMs = sleepTimeMs\r\n    this.maxQueueSize = maxQueueSize\r\n  }\r\n\r\n  async queue(func: Function) {\r\n    if (this.closed)\r\n      throw new Error(`Trying to queue a job to a closed ThreadPool`)\r\n\r\n    if (this.maxQueueSize !== Infinity) {\r\n      while (this.queuedTasks.length >= this.maxQueueSize) {\r\n        await sleep(this.sleepTimeMs)\r\n      }\r\n    }\r\n\r\n    this.queuedTasks.push({ func, index: this.queuedCount })\r\n    this._taskData.set(this.queuedCount, new TaskDesc())\r\n    this.queuedCount++\r\n  }\r\n\r\n  async _popAndRunNextTask () {\r\n    let taskToRun = this.queuedTasks.shift()\r\n    let taskData = this._taskData.get(taskToRun.index)\r\n    if (!taskData)\r\n      throw new Error('unexpected')\r\n    try {\r\n      this.startedCount++\r\n      taskData.startTime = Date.now()\r\n      await taskToRun.func()\r\n    } catch(err) {\r\n      try {\r\n        taskData.err = err\r\n        this.errorHandler(err)\r\n      } catch(err2) {\r\n        this.uncaughtErrors.push(err2)\r\n      }\r\n    }\r\n    this.endedCount++\r\n    taskData.endTime = Date.now()\r\n\r\n    // fire 'progress' event\r\n    this.emit('progress', { endedCount: this.endedCount })\r\n  }\r\n\r\n  async runAllQueued() {\r\n    this.close()\r\n    await this.run()\r\n  }\r\n\r\n  async run() {\r\n    this.startTimeMs = Date.now()\r\n    while (!this.closed || this.startedCount - this.endedCount > 0 || this.queuedTasks.length > 0) {\r\n      // TP is still open OR at least one task is running OR queued (we have work to do)\r\n\r\n      while(this.startedCount - this.endedCount < this.maxThreadsCount && this.queuedTasks.length > 0) {\r\n        // we can run more tasks\r\n        this._popAndRunNextTask()\r\n      }\r\n\r\n      if (!this.closed || this.startedCount - this.endedCount > 0) {\r\n        // TP is still open OR we are running and can't run more - now we wait\r\n        await sleep(this.sleepTimeMs)\r\n      }\r\n    }\r\n    this.endTimeMs = Date.now()\r\n\r\n    if (this.uncaughtErrors.length > 0) {\r\n      let error = (new Error(`${this.uncaughtErrors.length} errors were thrown during ThreadPool execution`): Object)\r\n      error.uncaughtErrors = this.uncaughtErrors\r\n      throw error\r\n    }\r\n  }\r\n\r\n  async waitComplete() {\r\n    while (!this.closed || this.startedCount - this.endedCount > 0 || this.queuedTasks.length > 0) {\r\n      await sleep(this.sleepTimeMs)\r\n    }\r\n  }\r\n\r\n  close() {\r\n    this.closed = true\r\n  }\r\n\r\n  async closeAndWaitComplete() {\r\n    this.close()\r\n    await this.waitComplete()\r\n  }\r\n\r\n  getLongestStillRunningMs() {\r\n    let now = Date.now()\r\n    let runTimes = Array.from(this._taskData.values())\r\n      .filter(td => td.startTime && !td.endTime)\r\n      // $FlowIgnore\r\n      .map(td => now - td.startTime)\r\n    let longestRunning = Math.max(...runTimes)\r\n    return longestRunning\r\n  }\r\n}\r\n"]}