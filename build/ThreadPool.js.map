{"version":3,"sources":["../src/ThreadPool.js"],"names":["DEFAULT_SLEEP_TIME_MS","TaskDesc","queueTime","Date","now","ThreadPool","maxThreadsCount","cpus","length","errorHandler","sleepTimeMs","maxQueueSize","Infinity","queuedTasks","queuedCount","startedCount","endedCount","uncaughtErrors","closed","_taskData","Map","Error","err","console","error","func","push","index","set","taskToRun","shift","taskData","get","startTime","err2","endTime","emit","close","run","startTimeMs","_popAndRunNextTask","endTimeMs","waitComplete","runTimes","Array","from","values","filter","td","map","longestRunning","Math","max"],"mappings":"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","file":"ThreadPool.js","sourcesContent":["// @flow\r\n\r\nimport \"babel-polyfill\"\r\nimport EventEmitter from 'events'\r\nimport os from 'os'\r\n\r\nimport { sleep } from './asyncUtils'\r\n\r\nconst DEFAULT_SLEEP_TIME_MS = 100\r\n\r\nclass TaskDesc {\r\n  queueTime: number\r\n  startTime: ?number\r\n  endTime: ?number\r\n  err: ?Error\r\n\r\n  constructor() {\r\n    this.queueTime = Date.now()\r\n  }\r\n}\r\n\r\n/**\r\n * A thread-pool abstraction for ES6 async operations\",\r\n * \r\n * @export\r\n * @class ThreadPool\r\n * @extends {EventEmitter}\r\n */\r\nexport default class ThreadPool extends EventEmitter {\r\n  startTimeMs: number\r\n  endTimeMs: number\r\n  maxThreadsCount: number\r\n  queuedTasks: Array<{ func: Function, index: number }> = []\r\n  queuedCount: number = 0\r\n  startedCount: number = 0\r\n  endedCount: number = 0\r\n  errorHandler: Function\r\n  uncaughtErrors: Array<Error> = []\r\n  sleepTimeMs: number\r\n  closed: boolean = false\r\n  maxQueueSize: number\r\n  _taskData: Map<number, TaskDesc> = new Map()\r\n\r\n  constructor(maxThreadsCount: number = os.cpus().length, errorHandler: ?Function, sleepTimeMs: number = DEFAULT_SLEEP_TIME_MS, maxQueueSize: number = Infinity) {\r\n    super()\r\n    \r\n    if (maxThreadsCount <= 0) {\r\n      throw new Error(`ThreadPool maxThreadsCount must be greater than 0`)\r\n    }\r\n    this.maxThreadsCount = maxThreadsCount\r\n    this.errorHandler = errorHandler || ((err) => console.error(err))  // eslint-disable-line no-console\r\n    this.sleepTimeMs = sleepTimeMs\r\n    this.maxQueueSize = maxQueueSize\r\n  }\r\n\r\n  async queue(func: Function) {\r\n    if (this.closed)\r\n      throw new Error(`Trying to queue a job to a closed ThreadPool`)\r\n\r\n    if (this.maxQueueSize !== Infinity) {\r\n      while (this.queuedTasks.length >= this.maxQueueSize) {\r\n        await sleep(this.sleepTimeMs)\r\n      }\r\n    }\r\n\r\n    this.queuedTasks.push({ func, index: this.queuedCount })\r\n    this._taskData.set(this.queuedCount, new TaskDesc())\r\n    this.queuedCount++\r\n  }\r\n\r\n  async _popAndRunNextTask () {\r\n    let taskToRun = this.queuedTasks.shift()\r\n    let taskData = this._taskData.get(taskToRun.index)\r\n    if (!taskData)\r\n      throw new Error('unexpected')\r\n    try {\r\n      this.startedCount++\r\n      taskData.startTime = Date.now()\r\n      await taskToRun.func()\r\n    } catch(err) {\r\n      try {\r\n        taskData.err = err\r\n        this.errorHandler(err)\r\n      } catch(err2) {\r\n        this.uncaughtErrors.push(err2)\r\n      }\r\n    }\r\n    this.endedCount++\r\n    taskData.endTime = Date.now()\r\n\r\n    // fire 'progress' event\r\n    this.emit('progress', { endedCount: this.endedCount })\r\n  }\r\n\r\n  async runAllQueued() {\r\n    this.close()\r\n    await this.run()\r\n  }\r\n\r\n  async run() {\r\n    this.startTimeMs = Date.now()\r\n    while (!this.closed || this.startedCount - this.endedCount > 0 || this.queuedTasks.length > 0) {\r\n      // TP is still open OR at least one task is running OR queued (we have work to do)\r\n\r\n      while(this.startedCount - this.endedCount < this.maxThreadsCount && this.queuedTasks.length > 0) {\r\n        // we can run more tasks\r\n        this._popAndRunNextTask()\r\n      }\r\n\r\n      if (!this.closed || this.startedCount - this.endedCount > 0) {\r\n        // TP is still open OR we are running and can't run more - now we wait\r\n        await sleep(this.sleepTimeMs)\r\n      }\r\n    }\r\n    this.endTimeMs = Date.now()\r\n\r\n    if (this.uncaughtErrors.length > 0) {\r\n      let error = (new Error(`${this.uncaughtErrors.length} errors were thrown during ThreadPool execution`): Object)\r\n      error.uncaughtErrors = this.uncaughtErrors\r\n      throw error\r\n    }\r\n  }\r\n\r\n  async waitComplete() {\r\n    while (!this.closed || this.startedCount - this.endedCount > 0 || this.queuedTasks.length > 0) {\r\n      await sleep(this.sleepTimeMs)\r\n    }\r\n  }\r\n\r\n  close() {\r\n    this.closed = true\r\n  }\r\n\r\n  async closeAndWaitComplete() {\r\n    this.close()\r\n    await this.waitComplete()\r\n  }\r\n\r\n  getLongestStillRunningMs() {\r\n    let now = Date.now()\r\n    let runTimes = Array.from(this._taskData.values())\r\n      .filter(td => td.startTime && !td.endTime)\r\n      // $FlowIgnore\r\n      .map(td => now - td.startTime)\r\n    let longestRunning = Math.max(...runTimes)\r\n    return longestRunning\r\n  }\r\n}\r\n"]}